{"version":3,"sources":["assets/icons/github.png","assets/icons/linkedin.png","assets/icons/CV.png","enums/cellType.tsx","components/cell.tsx","components/grid.tsx","enums/direction.tsx","constants.tsx","components/textContainer.tsx","components/sourceCodeLink.tsx","helpers/directionHelper.tsx","helpers/snakeHelper.tsx","helpers/gridHelper.tsx","helpers/windowHelper.tsx","components/main.tsx","index.tsx"],"names":["module","exports","CellType","React","memo","props","cellClass","cellKey","cellStyle","className","key","style","grid","cells","map","_","i","cell","j","Direction","footerLinks","title","link","id","image","uri","githubIcon","altText","linkedinIcon","cvIcon","sourceCodeLink","headings","class","cellClasses","Snake","Normal","Food","Debug","validKeyCodes","heading","index","element","href","alt","src","DirectionHelper","nextSnakeValid","snake","direction","SnakeHelper","validateSnake","getNextSnake","getNextDirection","foundFood","headCoordinates","Down","isFoodDown","Left","isFoodLeft","Right","isFoodRight","Up","isFoodUp","getRandomNextDirection","excludedDirection","allDirections","head","splice","indexOf","foodDirections","validDirections","dir","push","length","goldDirections","filter","foodDirection","Math","floor","random","coordinates","slice","y","array","x","c","type","getNewSnake","headX","width","headY","height","concat","snakeCell","addToTail","snakeCopy","tail","penultimate","nextHead","GridHelper","getNewGrid","newGrid","foodCount","cellType","opacity","WindowHelper","getNewWindowParams","window","innerWidth","innerHeight","Main","onKeyDown","event","defaultPrevented","code","setState","paused","debug","copy","state","userControlling","restart","timeout","clearInterval","setInterval","run","onWindowResized","windowResizeTimeout","clearTimeout","setTimeout","nextDirection","nextSnake","changes","newCell","change","addEventListener","newSnake","this","Component","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.4ba11e14.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyRpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6MzlFQkFERkU4NkJCMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6MzlFQkFERkQ4NkJCMTFFM0FBNTJFRTMzNTJEMUJDNDYiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoTWFjaW50b3NoKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkU1MTc4QTJFOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkU1MTc4QTJGOTlBMDExRTI5QTE1QkMxMDQ2QTg5MDREIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Kk5lQwAABYxJREFUeNrkm29oVXUYx3+7bM3V1FnbqlltrtXWtYRa1nqxooY5E7EhKWGuaTDBagol9SIMDCKICASj+cISw/DPi16ZBakrUBnoC7nNoTMWy6I1c+LmVq6t78N9jpyu555znt855+536IHPi939/jzP95zznN+/kzc1NaUitirwJJgPasF94DZQDG7hMqNgBFwEZ5kU+AH0R+lcXgQCJMBT4EXwLKgM2N7P4FvwJegCk6YKUA5eB23grogu2C/gc7AN/GGKABTsZtAOZqjc2DjYAT5kUfSNBNCkAGwGo1PTZ6PsQ4FuHLp3QD3YDR5QZtgZsAac1ElYokcGbATHDApesS/kUwf7GEkOKAK7wAvKbNsPXgZjYQowG3wNnlDxsONgCbgchgAU/GHwiIqXUT5o8hLBKwfcDA7FMHgrUR/iGLQEoGTyBWhQ8bUGjiFPR4A3QIuKv7VwLKIcQMnue5Dv0fjT/IwtAM3g+RyMBmkU+BXf3qc5Rx3xqDPBE7LjfkaCheCcj1HYKYe6JeBt8GcEo75L3HaJQ7+nfNQ/x7H9p67TFX4L1Pi4EocdfhsGH4BPwVbwqu0xGwI/8vT2N/77Gv+vAJSCO3n6PJ//Vjz72w62cPtORnfAwx7+1nBsW93ugGow7vOKtPkYa9eDl0Clxji9kuvW+yjb5tPncY7xet3MhjoFt2RzgIlU2DQL/O6017W/Be4BawXJqMCgTH+ToOxajvWG1+AmYVBlBglQKrxwmzIFoB9XCzt91CABpL6sti62JcBiXtKS2GMGCSD1pZxjvi7AKmED9PraYJAAG2yvVL+2yi7AImHl90C3QQJ03/B+97ZF1lCYVlN6BBV/BffykNQkoyF4H5grqJOkO6BR2NF2A4O35gifCOs0JjTW9vYaPPPbJ11LJAFqBRVoDf68wQLQI3BBUL424XPiY1lvDOb/ZwRla0iAOYIKv8dAgEFB2VtJgJmCChMxEEAyHigmAQoFFWbFQIDZgrKF0p2hmTEQQOQjCTAmKD8vBgJUCcqOkQBXBBXosEORwcEXKdmBjCskwICgQr5h0+BMW6i8V7LtNkAC9As7WWqwAM8Jy/cnhBMhspVKvq2eC0uwbxLrSWhMa+dpdJQLW6mRpLtpOlyuMcL7CTwErhoSPG2ApjQEuD3BQ0fp0ZJqlT6pZYpt0wieYh60nuWDGp2+At4xIPgt7IvU0jHzBkFdgD27HWDGNGyGFHHfulaXuTN0IkBjZ8EykJeDwKmPFtAXwN8TTltjrVkKfwcawXJW3G3v8DTYCKoiCLwGvAl6QthpbnU6J5jP2f1uh1Wgxbbxwv0qvT/vtZRGA6wuzs50+Pkb8JdgQtPMq1VJld7bnxtSzhjgJD5hzwEW611OZK6xlSvzeYbAsl3Cx4PK7ozodOl6t93hfJByqbzOVnYh+MdHhxfBLI1bnuoMhRx8imPMKgDR5LG/nrSVfddHpx8HeO4/ClmApsw+snXsdk7gYMat+r5Hp0sDCLAkxOA7nfrI1nGxx2tmQUb5x8FuzgvD4Dw4wNm2MIAA1SEF38cx+RaAeBCMZGlwb44GOyUhBD/CsTj24TatpddXq3L+RIVmXnE4QzjJMaSylvBxFdqzKHsVrDD8Dmj36sOvIx0unewHDRENg4MI0BH2FyP0RcZOlzW3Ib7VLvPqDK0z1PEq7bDmLVwCLgnr0AhvnUp/0eJp0k9m6HO4fUp2nGZODgUY5PzUJVlHkxg1TEfnjxqY8I6yb12SSjqLm7T9/Ax4TaW/+JxuIx862KcL4toBk1QFT1omXZLRHQHaL3Npl/r8jH3QjiGsbJ3kGd/fDo6WBWi31KG9a9xXMgzfw35tVfCR9l52dk8Ibe7htnq57YowfY7i4+lYWUL9z+1fAQYACqstE4NCc18AAAAASUVORK5CYII=\"","module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAACXBIWXMAAA7EAAAOxAGVKw4bAAADWElEQVR42u2bTUhUURTHf2cQkZCIFhEhIhUSKn1swsIWhtSmWgSB2apNEgRRLfrcRYTLNpW7CCwTgqAPCKHalQQSQS2CPnAVIhEiYjLNv8XcoWEax/v8au577w9vM5x73/zPO+d/zrvvXqMCJDUB3UAn0AKsA2qpbswC48BH4CUwaGbfIs0gqVHSfUm/FT5+Oy6N5bhaGfI9QD9QT7wwBfSa2b3iHzMl5M8CAzEkj+M04Dj+GwHuyQ+QDBwrRIIVch74ENMnP1c6tJrZWCEF+hJEvpAOfQDmSt3nUj1IAHLApoyr80kjXygA3RnX5CQVnTWuw4uCSeCN67bqgZ3AhkAd0GKSfnm2tzPAZeCmmc0Ulc8McAi4BawPzAGzJkmegnHQzJ5VaJ+bgRFgTWhC4IPBSuQBzOwTcD1EJfTBA0+7obg6YCyCXTaODvDN63qgJo4O2O9pty+0FPCtApPAtkorK5JWAW8X0FcEEQGrgeeS2uYgvwF4Ghr5KBFQQBZ4Qn6tbcJpwy7gMLAqxFYwqgNi+UZE6oAwMOOuJYVvzf4ODHrYNTo9KMYr4J3H2HZ3FTAB3AEeA+/N7KcT3DpgI9ABHAG6FuUBz7X1Ec+5usqMPeU59lLRmBuS6j3HbZf0eqEfDTJVlCo5dx03s9NmNuWl4mbvgD3A7WrQgNwixmaBi2Z2J3IpM8sCJ4G7y6UBKyG0L4DRBddzMySdBHYDm4OrAmY2amaLnWMaOL8cTyekcvkI+BKiBhQre62rKCck9UhqiBAFOeBeNaVAJiL5veQ/1AyT/0o9AHyVdCXCNMNBdoKS2t1bZUMZsb4q6YDnVKO+0Vg1GuB6kn6groLZGc80mHLda1AR0A5sncemQ5LvFp3/4oDcIu6xxcOm1r1v+GA6tAjw/Tzvu0CbDUoDItyj9n/cNF0QWQENSFeEqtkBmTQFUgekGpBqQJoCqQNSDUg1IE2BGDpgNsEaMJshv+U1qRivIX+6ar5l5wZJDz0mXFvmt6OSdniMbfb809ck/fCwa/Ow+WiSLhDgDs8lwsX0wITb+jaUwKc/ZGbf0kNTAGY2BvQm6On3Os5/896dozuXAPLnik+PpkdnS62cQSv5XWG5GBDPOS6tpeTLRkBJNDQR8+PzfwAKsmTebXr8QwAAAABJRU5ErkJggg==\"","module.exports = \"data:image/png;base64,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\"","export enum CellType {\n  Snake,\n  Food,\n  Normal,\n  Debug,\n}\n","import React from \"react\";\nimport ICellProps from \"../interfaces/cellProps\";\n\nconst Cell = (props: ICellProps) => {\n  const { cellClass, cellKey, cellStyle } = props;\n\n  return (\n    <div className={`cell ${cellClass}`} key={cellKey} style={cellStyle} />\n  );\n};\n\nexport default React.memo(Cell);\n","import React from \"react\";\nimport IGridProps from \"../interfaces/gridProps\";\nimport ICellDescriptor from \"../interfaces/cellDescriptor\";\nimport Cell from \"./cell\";\n\nconst Grid = (props: IGridProps) => {\n  const { grid } = props;\n\n  return (\n    <div className=\"grid\">\n      {grid.cells.map((_: ICellDescriptor[], i: number) =>\n        grid.cells[i].map((cell: ICellDescriptor, j: number) => {\n          let cellKey = i + \"_\" + j;\n\n          return (\n            <Cell\n              key={cellKey}\n              cellClass={cell.cellClass}\n              cellKey={cellKey}\n              cellStyle={cell.style}\n            />\n          );\n        })\n      )}\n    </div>\n  );\n};\n\nexport default React.memo(Grid);\n","export enum Direction {\n  None,\n  Left,\n  Right,\n  Up,\n  Down,\n}\n","import IFooterLink from \"./interfaces/footer\";\nimport IHeader from \"./interfaces/header\";\nimport { CellType } from \"./enums/cellType\";\nimport githubIcon from \"./assets/icons/github.png\";\nimport linkedinIcon from \"./assets/icons/linkedin.png\";\nimport cvIcon from \"./assets/icons/CV.png\";\n\nexport const DefaultRowCount: number = 200;\nexport const DefaultColumnCount: number = 200;\nexport const DefaultBoxWidth: number = 17;\nexport const DefaultBoxHeight: number = 17;\nexport const FoodChance: number = 0.995;\nexport const Interval: number = 5;\nexport const InitialSnakeLength: number = 5;\n\nexport const footerLinks: IFooterLink[] = [\n  {\n    title: \"GitHub\",\n    link: \"https://github.com/OliverMBathurst\",\n    id: 0,\n    image: {\n      uri: githubIcon,\n      altText: \"GitHub\",\n    },\n  },\n  {\n    title: \"LinkedIn\",\n    link: \"https://www.linkedin.com/in/oliverbathurst/\",\n    id: 1,\n    image: {\n      uri: linkedinIcon,\n      altText: \"LinkedIn\",\n    },\n  },\n  {\n    title: \"CV\",\n    link:\n      \"https://github.com/OliverMBathurst/Curriculum-Vitae/raw/master/Oliver%20Bathurst%20CV.pdf\",\n    id: 2,\n    image: {\n      uri: cvIcon,\n      altText: \"CV\",\n    },\n  },\n];\n\nexport const sourceCodeLink: IFooterLink = {\n  title: \"</>\",\n  link: \"https://github.com/OliverMBathurst/olivermbathurst.github.io\",\n  id: 3,\n  image: null,\n};\n\nexport const headings: IHeader[] = [\n  {\n    title: \"Oliver Bathurst\",\n    class: \"heading\",\n  },\n  {\n    title: \"Full-Stack Developer\",\n    class: \"sub-heading\",\n  },\n];\n\nexport const cellClasses: { [index: number]: string } = {\n  [CellType.Snake]: \"snake\",\n  [CellType.Normal]: \"normal\",\n  [CellType.Food]: \"food\",\n  [CellType.Debug]: \"debug\",\n};\n\nexport const validKeyCodes: string[] = [\n  \"KeyP\",\n  \"KeyR\",\n  \"KeyD\",\n  \"ArrowRight\",\n  \"ArrowLeft\",\n  \"ArrowUp\",\n  \"ArrowDown\",\n];\n","import React from \"react\";\nimport IHeader from \"../interfaces/header\";\nimport { headings, footerLinks } from \"../constants\";\nimport IFooterLink from \"../interfaces/footer\";\n\nconst TextContainer = () => {\n  return (\n    <>\n      <div className=\"headingContainer\">\n        <div className=\"overlay\" />\n        {headings.map((heading: IHeader, index) => (\n          <span key={index} className={heading.class}>\n            {heading.title}\n          </span>\n        ))}\n        <div className=\"buttonContainer\">\n          {footerLinks.map((element: IFooterLink) => (\n            <a className=\"headerButton\" key={element.id} href={element.link}>\n              {element.image ? (\n                <img\n                  alt={element.image.altText}\n                  className=\"image\"\n                  src={element.image.uri}\n                />\n              ) : (\n                element.title\n              )}\n            </a>\n          ))}\n        </div>\n      </div>\n    </>\n  );\n};\n\nexport default React.memo(TextContainer);\n","import React from \"react\";\nimport { sourceCodeLink } from \"../constants\";\n\nconst SourceCodeLink = () => {\n  const { link, title, id } = sourceCodeLink;\n\n  return (\n    <a className=\"sourceCodeButton\" href={link} key={id}>\n      {title}\n    </a>\n  );\n};\n\nexport default React.memo(SourceCodeLink);\n","import { Direction } from \"../enums/direction\";\nimport { CellType } from \"../enums/cellType\";\nimport ICellDescriptor from \"../interfaces/cellDescriptor\";\nimport ICoordinates from \"../interfaces/coordinates\";\nimport IGrid from \"../interfaces/grid\";\nimport ISnake from \"../interfaces/snake\";\nimport SnakeHelper from \"./snakeHelper\";\n\nexport default class DirectionHelper {\n  static nextSnakeValid = (\n    snake: ISnake,\n    direction: Direction,\n    grid: IGrid\n  ): boolean => {\n    return SnakeHelper.validateSnake(\n      SnakeHelper.getNextSnake(snake, direction, grid),\n      grid\n    );\n  };\n\n  static getNextDirection = (snake: ISnake, grid: IGrid): Direction => {\n    var foundFood: boolean = false;\n    var headCoordinates = snake.cells[0];\n\n    switch (snake.direction) {\n      case Direction.Down:\n        foundFood = DirectionHelper.isFoodDown(headCoordinates, grid);\n        break;\n      case Direction.Left:\n        foundFood = DirectionHelper.isFoodLeft(headCoordinates, grid);\n        break;\n      case Direction.Right:\n        foundFood = DirectionHelper.isFoodRight(headCoordinates, grid);\n        break;\n      case Direction.Up:\n        foundFood = DirectionHelper.isFoodUp(headCoordinates, grid);\n        break;\n    }\n\n    return foundFood &&\n      DirectionHelper.nextSnakeValid(snake, snake.direction, grid)\n      ? snake.direction\n      : DirectionHelper.getRandomNextDirection(snake, snake.direction, grid);\n  };\n\n  static getRandomNextDirection = (\n    snake: ISnake,\n    excludedDirection: Direction,\n    grid: IGrid\n  ): Direction => {\n    var allDirections: Direction[] = [\n      Direction.Down,\n      Direction.Left,\n      Direction.Right,\n      Direction.Up,\n    ];\n\n    const head = snake.cells[0];\n\n    allDirections.splice(allDirections.indexOf(excludedDirection), 1);\n\n    var foodDirections: Direction[] = [];\n    var validDirections: Direction[] = [];\n\n    for (var dir of allDirections) {\n      var foundFood: boolean = false;\n\n      if (dir === Direction.Down && DirectionHelper.isFoodDown(head, grid)) {\n        foundFood = true;\n      } else if (dir === Direction.Up && DirectionHelper.isFoodUp(head, grid)) {\n        foundFood = true;\n      } else if (\n        dir === Direction.Right &&\n        DirectionHelper.isFoodRight(head, grid)\n      ) {\n        foundFood = true;\n      } else if (\n        dir === Direction.Left &&\n        DirectionHelper.isFoodLeft(head, grid)\n      ) {\n        foundFood = true;\n      }\n\n      if (DirectionHelper.nextSnakeValid(snake, dir, grid)) {\n        validDirections.push(dir);\n      }\n\n      if (foundFood) {\n        foodDirections.push(dir);\n      }\n    }\n\n    if (foodDirections.length > 0) {\n      var goldDirections = foodDirections.filter(\n        (foodDirection) => validDirections.indexOf(foodDirection) !== -1\n      );\n      if (goldDirections.length > 0) {\n        return goldDirections[\n          Math.floor(Math.random() * goldDirections.length)\n        ];\n      }\n    }\n\n    if (validDirections.length > 0) {\n      return validDirections[\n        Math.floor(Math.random() * validDirections.length)\n      ];\n    }\n\n    return Direction.Right;\n  };\n\n  static isFoodDown = (coordinates: ICoordinates, grid: IGrid): boolean => {\n    return (\n      grid.cells\n        .slice(coordinates.y, grid.cells.length)\n        .map((array: ICellDescriptor[]) => array[coordinates.x])\n        .filter((c: ICellDescriptor) => c.type === CellType.Food).length > 0\n    );\n  };\n\n  static isFoodUp = (coordinates: ICoordinates, grid: IGrid): boolean => {\n    return (\n      grid.cells\n        .slice(0, coordinates.y)\n        .map((array: ICellDescriptor[]) => array[coordinates.x])\n        .filter((c: ICellDescriptor) => c.type === CellType.Food).length > 0\n    );\n  };\n\n  static isFoodRight = (coordinates: ICoordinates, grid: IGrid): boolean => {\n    return (\n      grid.cells[coordinates.y]\n        .slice(coordinates.x, grid.cells[coordinates.y].length)\n        .filter((c: ICellDescriptor) => c.type === CellType.Food).length > 0\n    );\n  };\n\n  static isFoodLeft = (coordinates: ICoordinates, grid: IGrid): boolean => {\n    return (\n      grid.cells[coordinates.y]\n        .slice(0, coordinates.x)\n        .filter((c: ICellDescriptor) => c.type === CellType.Food).length > 0\n    );\n  };\n}\n","import { InitialSnakeLength } from \"../constants\";\nimport { Direction } from \"../enums/direction\";\nimport ICoordinates from \"../interfaces/coordinates\";\nimport IGrid from \"../interfaces/grid\";\nimport ISnake from \"../interfaces/snake\";\nimport DirectionHelper from \"./directionHelper\";\n\nexport default class SnakeHelper {\n  static getNewSnake = (grid: IGrid): ISnake => {\n    var headX = Math.floor(\n      Math.random() * (grid.width - 2 * InitialSnakeLength) + InitialSnakeLength\n    );\n    var headY = Math.floor(\n      Math.random() * (grid.height - 2 * InitialSnakeLength) +\n        InitialSnakeLength\n    );\n\n    var snake: ISnake = {\n      cells: [{ x: headX, y: headY }],\n      direction: Direction.Right,\n    };\n\n    for (var c = 1; c < InitialSnakeLength; c++) {\n      snake.cells = snake.cells.concat({ x: headX - c, y: headY });\n    }\n\n    var allDirections: Direction[] = [\n      Direction.Left,\n      Direction.Right,\n      Direction.Down,\n      Direction.Up,\n    ];\n    var validDirections: Direction[] = [];\n\n    for (const dir of allDirections) {\n      if (DirectionHelper.nextSnakeValid(snake, dir, grid)) {\n        validDirections.push(dir);\n      }\n    }\n\n    if (validDirections.length !== 0) {\n      snake.direction =\n        validDirections[Math.floor(Math.random() * validDirections.length)];\n    }\n\n    return snake;\n  };\n\n  static validateSnake = (snake: ISnake, grid: IGrid): boolean => {\n    for (let i = 0; i < snake.cells.length; i++) {\n      const cell = snake.cells[i];\n\n      if (\n        snake.cells.filter(\n          (snakeCell) => snakeCell.x === cell.x && snakeCell.y === cell.y\n        ).length > 1\n      ) {\n        return false;\n      }\n\n      if (cell.y < 0 || cell.y > grid.cells.length - 1) {\n        return false;\n      }\n\n      if (cell.x < 0 || cell.x > grid.cells[cell.y].length - 1) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  static addToTail = (snake: ISnake, grid: IGrid): ISnake => {\n    var snakeCopy: ISnake = {\n      direction: snake.direction,\n      cells: [...snake.cells],\n    };\n    var tail = snakeCopy.cells[snakeCopy.cells.length - 1];\n    var penultimate = snakeCopy.cells[snakeCopy.cells.length - 2];\n\n    if (tail.x > penultimate.x) {\n      snakeCopy.cells = snakeCopy.cells.concat({\n        x: tail.x + 1 > grid.cells[tail.y].length - 1 ? 0 : tail.x + 1,\n        y: tail.y,\n      });\n    } else if (penultimate.x > tail.x) {\n      snakeCopy.cells = snakeCopy.cells.concat({\n        x: tail.x - 1 < 0 ? grid.cells[tail.y].length - 1 : tail.x - 1,\n        y: tail.y,\n      });\n    } else {\n      if (penultimate.y < tail.y) {\n        snakeCopy.cells = snakeCopy.cells.concat({\n          x: tail.x,\n          y: tail.y + 1 > grid.cells.length - 1 ? 0 : tail.y + 1,\n        });\n      } else {\n        snakeCopy.cells = snakeCopy.cells.concat({\n          x: tail.x,\n          y: tail.y - 1 < 0 ? grid.cells.length - 1 : tail.y - 1,\n        });\n      }\n    }\n\n    return snakeCopy;\n  };\n\n  static getNextSnake = (\n    snake: ISnake,\n    direction: Direction,\n    grid: IGrid\n  ): ISnake => {\n    var snakeCopy: ISnake = {\n      direction: snake.direction,\n      cells: [...snake.cells],\n    };\n    var head = snakeCopy.cells[0];\n    var nextHead: ICoordinates;\n\n    if (direction === Direction.Right) {\n      nextHead = {\n        x: head.x + 1 < grid.cells[head.y].length ? head.x + 1 : 0,\n        y: head.y,\n      };\n    } else if (direction === Direction.Down) {\n      nextHead = {\n        x: head.x,\n        y: head.y + 1 > grid.cells.length - 1 ? 0 : head.y + 1,\n      };\n    } else if (direction === Direction.Left) {\n      nextHead = {\n        x: head.x - 1 < 0 ? grid.cells[head.y].length - 1 : head.x - 1,\n        y: head.y,\n      };\n    } else if (direction === Direction.Up) {\n      nextHead = {\n        x: head.x,\n        y: head.y - 1 < 0 ? grid.cells.length - 1 : head.y - 1,\n      };\n    } else {\n      nextHead = { ...head };\n    }\n\n    for (var i = snakeCopy.cells.length - 1; i > 0; i--) {\n      snakeCopy.cells[i] = snakeCopy.cells[i - 1];\n    }\n\n    snakeCopy.cells[0] = nextHead;\n    snakeCopy.direction = direction;\n\n    return snakeCopy;\n  };\n}\n","import ICellDescriptor from \"../interfaces/cellDescriptor\";\nimport IGrid from \"../interfaces/grid\";\nimport { CellType } from \"../enums/cellType\";\nimport { FoodChance, cellClasses } from \"../constants\";\n\nexport default class GridHelper {\n  static getNewGrid = (width: number, height: number): IGrid => {\n    var newGrid: ICellDescriptor[][] = [];\n    var foodCount: number = 0;\n\n    for (var i = 0; i < height; i++) {\n      newGrid[i] = [];\n      for (var j = 0; j < width; j++) {\n        var cellType =\n          Math.random() > FoodChance ? CellType.Food : CellType.Normal;\n        if (cellType === CellType.Food) {\n          foodCount++;\n        }\n\n        var style =\n          cellType === CellType.Food\n            ? { opacity: Math.random() > 0.5 ? 1 : 0.5 }\n            : {};\n\n        newGrid[i][j] = {\n          type: cellType,\n          cellClass: cellClasses[cellType],\n          style: style,\n        };\n      }\n    }\n\n    return {\n      cells: newGrid,\n      foodCount: foodCount,\n      height: height,\n      width: width,\n    };\n  };\n}\n","import { DefaultBoxHeight, DefaultBoxWidth } from \"../constants\";\nimport IWindowParameters from \"../interfaces/windowParameters\";\n\nexport default class WindowHelper {\n  static getNewWindowParams = (): IWindowParameters => {\n    return {\n      width: Math.floor(window.innerWidth / DefaultBoxWidth),\n      height: Math.floor(window.innerHeight / DefaultBoxHeight),\n    };\n  };\n}\n","import React, { Component } from \"react\";\nimport Grid from \"./grid\";\nimport IState from \"../interfaces/state\";\nimport IProps from \"../interfaces/props\";\nimport IWindowParameters from \"../interfaces/windowParameters\";\nimport TextContainer from \"./textContainer\";\nimport SourceCodeLink from \"./sourceCodeLink\";\nimport SnakeHelper from \"../helpers/snakeHelper\";\nimport GridHelper from \"../helpers/gridHelper\";\nimport DirectionHelper from \"../helpers/directionHelper\";\nimport WindowHelper from \"../helpers/windowHelper\";\nimport {\n  Interval,\n  validKeyCodes,\n  cellClasses,\n  InitialSnakeLength,\n} from \"../constants\";\nimport { CellType } from \"../enums/cellType\";\nimport { Direction } from \"../enums/direction\";\nimport IGridChange from \"../interfaces/gridChange\";\n\nclass Main extends Component<IProps, IState> {\n  constructor(props: IProps) {\n    super(props);\n\n    window.addEventListener(\"resize\", this.onWindowResized);\n    window.addEventListener(\"keydown\", this.onKeyDown);\n\n    const {\n      width,\n      height,\n    }: IWindowParameters = WindowHelper.getNewWindowParams();\n\n    var newGrid = GridHelper.getNewGrid(width, height);\n    var newSnake = SnakeHelper.getNewSnake(newGrid);\n\n    for (const cell of newSnake.cells) {\n      newGrid.cells[cell.y][cell.x] = {\n        type: CellType.Snake,\n        cellClass: cellClasses[CellType.Snake],\n      };\n    }\n\n    this.state = {\n      grid: newGrid,\n      snake: newSnake,\n      timeout: setInterval(this.run, Interval),\n      userControlling: false,\n      paused: false,\n      debug: false,\n      windowResizeTimeout: null,\n    };\n  }\n\n  onKeyDown = (event: KeyboardEvent) => {\n    if (event.defaultPrevented) {\n      return;\n    }\n\n    if (validKeyCodes.indexOf(event.code) !== -1) {\n      if (event.code === \"KeyP\" || event.code === \"KeyR\") {\n        this.setState({\n          paused: event.code === \"KeyP\",\n        });\n        return;\n      }\n\n      if (event.code === \"KeyD\") {\n        this.setState({\n          debug: true,\n        });\n        return;\n      }\n\n      var copy = { ...this.state.snake };\n      if (event.code === \"ArrowRight\") {\n        copy.direction = Direction.Right;\n      } else if (event.code === \"ArrowLeft\") {\n        copy.direction = Direction.Left;\n      } else if (event.code === \"ArrowDown\") {\n        copy.direction = Direction.Down;\n      } else if (event.code === \"ArrowUp\") {\n        copy.direction = Direction.Up;\n      }\n\n      this.setState({\n        snake: copy,\n        userControlling: true,\n      });\n    }\n  };\n\n  restart = () => {\n    if (this.state.timeout) {\n      clearInterval(this.state.timeout);\n    }\n\n    if (!this.state.paused) {\n      this.setState({ paused: true });\n    }\n\n    var {\n      width,\n      height,\n    }: IWindowParameters = WindowHelper.getNewWindowParams();\n\n    var newGrid = GridHelper.getNewGrid(width, height);\n    this.setState({\n      grid: newGrid,\n      snake: SnakeHelper.getNewSnake(newGrid),\n      userControlling: false,\n      timeout: setInterval(this.run, Interval),\n      paused: false,\n    });\n  };\n\n  onWindowResized = () => {\n    this.setState({ paused: true });\n\n    if (this.state.windowResizeTimeout) {\n      clearTimeout(this.state.windowResizeTimeout);\n    }\n\n    this.setState({\n      windowResizeTimeout: setTimeout(this.restart, 200),\n    });\n  };\n\n  run = (): void => {\n    if (this.state.paused) {\n      return;\n    }\n\n    var snakeCopy = {\n      direction: this.state.snake.direction,\n      cells: [...this.state.snake.cells],\n    };\n\n    if (\n      snakeCopy.cells.length ===\n      InitialSnakeLength + this.state.grid.foodCount\n    ) {\n      this.restart();\n      return;\n    }\n\n    var nextDirection = this.state.userControlling\n      ? snakeCopy.direction\n      : DirectionHelper.getNextDirection(snakeCopy, this.state.grid);\n\n    var nextSnake = SnakeHelper.getNextSnake(\n      snakeCopy,\n      nextDirection,\n      this.state.grid\n    );\n\n    if (!SnakeHelper.validateSnake(nextSnake, this.state.grid)) {\n      this.restart();\n      return;\n    }\n\n    if (\n      this.state.grid.cells[nextSnake.cells[0].y][nextSnake.cells[0].x].type ===\n      CellType.Food\n    ) {\n      nextSnake = SnakeHelper.addToTail(nextSnake, this.state.grid);\n      if (!SnakeHelper.validateSnake(nextSnake, this.state.grid)) {\n        this.restart();\n        return;\n      }\n    }\n\n    var changes: IGridChange[] = [];\n\n    for (const cell of this.state.snake.cells) {\n      if (\n        nextSnake.cells.filter(\n          (newCell) => newCell.x === cell.x && newCell.y === cell.y\n        ).length === 0\n      ) {\n        changes.push({\n          coordinates: { x: cell.x, y: cell.y },\n          cell: {\n            type: CellType.Normal,\n            cellClass: cellClasses[CellType.Normal],\n          },\n        });\n      }\n    }\n\n    for (const cell of nextSnake.cells) {\n      if (this.state.grid.cells[cell.y][cell.x].type !== CellType.Snake) {\n        changes.push({\n          coordinates: { x: cell.x, y: cell.y },\n          cell: {\n            type: CellType.Snake,\n            cellClass: cellClasses[CellType.Snake],\n          },\n        });\n      }\n    }\n\n    if (changes.length > 0) {\n      var copy = { ...this.state.grid };\n      for (var change of changes) {\n        copy.cells[change.coordinates.y][change.coordinates.x] = change.cell;\n      }\n      this.setState({\n        grid: copy,\n        snake: nextSnake,\n      });\n      return;\n    }\n\n    this.setState({\n      snake: nextSnake,\n    });\n  };\n\n  render() {\n    return (\n      <>\n        <div>\n          {!this.state.userControlling && <TextContainer />}\n          <Grid grid={this.state.grid} />\n          <SourceCodeLink />\n        </div>\n      </>\n    );\n  }\n}\n\nexport default Main;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport Main from \"./components/main\";\n\nReactDOM.render(<Main />, document.getElementById(\"root\"));\n"],"sourceRoot":""}